class VersionHelperConstants {
    static final REGEX_VERSION = /^(\d+.)+\d+$/
    static final REGEX_SNAPSHOT=/^(\d+.)+\d+-SNAPSHOT$/
}

/*
 Allow access to the REGEX_VERSION constant from this & other scripts
*/
def REGEX_VERSION() {
	return VersionHelperConstants.REGEX_VERSION
}

/*
 Allow access to the REGEX_SNAPSHOT constant from this & other scripts
*/
def REGEX_SNAPSHOT() {
	return VersionHelperConstants.REGEX_SNAPSHOT
}

/*
 Get the current project version. If the overrideVersion property is defined,
 this method returns the property value. Otherwise, the getProjectVersionFromGit()
 method is called to determine the current project version from current Git status
 (branch name, version tag, ...).
*/
def getProjectVersion() {
	return project.findProperty('overrideVersion') ?: getProjectVersionFromGit()
}

/*
 Get the current project version by calling the getProjectVersion() method,
 transforming the result as follows:
 - If project version matches REGEX_SNAPSHOT, replace 'SNAPSHOT' with 'beta' and
   append current date/time. Example: 5.4-beta-20191231-235930
 - If project version matches REGEX_VERSION, append '-release'. Example: 5.4-release
 - Otherwise, append '-alpha' and current date/time. 
   Example: 5.3-58-g46785b0-alpha-20191231-235930
   
No date/timestamp will be included in the result if the optional includeTimestamp 
parameter is set to false, for example returning 5.4-beta or 5.3-58-g46785b0-alpha.
*/
def getProjectVersionAsBetaOrRelease(includeTimestamp = true) {
	def dateTimeSuffix = includeTimestamp 
		? ('-'+new Date().format('yyyyMMdd-HHmmss'))
		: ''
	def projectVersion = getProjectVersion()
	if ( projectVersion ==~ REGEX_SNAPSHOT() ) {
		return projectVersion.replace("-SNAPSHOT", "-beta${dateTimeSuffix}")
	} else if ( projectVersion ==~ REGEX_VERSION() ) {
		return projectVersion + "-release"
	} else {
		return projectVersion + "-alpha-${dateTimeSuffix}"
	}
}

/*
 Get the current project version by calling the getProjectVersion() method,
 transforming the result as follows:
 - If project version matches REGEX_VERSION, return the project version as-is
 - Otherwise, return '0.<yyyyMMdd>.<HHmmss>'
 
 Semantically, this basically means that snapshot versions always have lower 
 version numbers than tagged versions (assuming tagged versions start at 1.0). 
 
 For example, plugin-based systems that check plugin version numbers (like the 
 Fortify SSC parser plugin framework) will disallow activating a snapshot version 
 if a tagged version is already installed. The tagged version(s) will need to be 
 de-activated/uninstalled before a snapshot version can be installed.  However, if 
 a snapshot version is currently installed/active, it can be updated with either
 a new snapshot build (which will have a higher minor or patch version number), or
 a new tagged build. 
*/
def getProjectVersionAsPlainVersionNumber() {
	def projectVersion = getProjectVersion()
	if ( projectVersion ==~ REGEX_VERSION() ) {
		return projectVersion
	} else {
		return "0."+new Date().format('yyyyMMdd.HHmmss')
	}
}

/*
 Determine the current project version from the current Git status. Version numbers 
 are assumed to be dot-separated digits; although any number of dots and digits can 
 be used, it is recommended to use <major>.<minor> or <major>.<minor>.<patch>.
 
 The current project version number is determined as follows, in this order: 
 - If current commit is not tagged with a version number, and current branch is named 
   <version>-SNAPSHOT, return the current branch name.
 - If current commit is tagged, return the tag name (as returned by 'git describe'). 
   It is assumed that each tag can be interpreted as a version number
 - If the current workspace is clean (no uncommitted changes), the output of 'git describe --always'
   is returned, i.e. something like '<lastversion>-<nrOfCommitsSinceLastVersion>-<commit id>'
   if there is a previously tagged version, or '<commit id>' if there is no previously 
   tagged version.
 - If the current workspace is not clean, the output of 'git describe --always' is returned 
   as above, but with the string '-localchanges' appended.
*/
def getProjectVersionFromGit() {
	def branchName = grgit.branch.current().name
	def gitDescribe = grgit.describe(tags: true, always: true)
	def isClean = grgit.status().isClean()
	if ( !isClean ) {
		gitDescribe += '-localchanges'
	}
	if ( !(gitDescribe ==~ REGEX_VERSION()) && branchName ==~ REGEX_SNAPSHOT() ) {
		return branchName
	} else {
		return gitDescribe
	}
}

/**
 Check whether current workspace is clean (no uncommitted changes)
*/
def checkClean() {
	def isClean = grgit.status().isClean()
	if ( !isClean ) {
		throw new GradleException('ERROR: Working copy has uncommitted changes')
	}
}

/**
 Add public function references as extra Gradle properties. 
*/
ext {
	REGEX_VERSION = this.&REGEX_VERSION
    REGEX_SNAPSHOT = this.&REGEX_SNAPSHOT
    getProjectVersion = this.&getProjectVersion
    getProjectVersionAsBetaOrRelease = this.&getProjectVersionAsBetaOrRelease
    getProjectVersionAsPlainVersionNumber = this.&getProjectVersionAsPlainVersionNumber
    getProjectVersionFromGit = this.&getProjectVersionFromGit
    checkClean = this.&checkClean
}

/**
 Task to print the current project version. 
*/
task printProjectVersion {
    doLast {
        println project.version
    }
}

/**
 Task to print the project version as returned by the getProjectVersion() method. 
*/
task getProjectVersion {
    doLast {
        println getProjectVersion()
    }
}

/**
 Task to print the project version as returned by the getProjectVersionAsBetaOrRelease() method. 
*/
task getProjectVersionAsBetaOrReleaseWithTimestamp {
    doLast {
        println getProjectVersionAsBetaOrRelease(true)
    }
}

/**
 Task to print the project version as returned by the getProjectVersionAsBetaOrRelease() method. 
*/
task getProjectVersionAsBetaOrReleaseWithoutTimestamp {
    doLast {
        println getProjectVersionAsBetaOrRelease(false)
    }
}

/**
 Task to print the project version as returned by the getProjectVersion() method. 
*/
task getProjectVersionAsPlainVersionNumber {
    doLast {
        println getProjectVersionAsPlainVersionNumber()
    }
}

/**
 Task to create a release from a current snapshot branch. 
 
 Task prerequisites:
 - Currently checked out branch is named <version>-SNAPSHOT
 - Workspace has no uncommitted changes
 
 Task actions:
 - Merge changes from current snapshot branch with master branch
 - Tag merged changes with the version number specified in the
   snapshot branch name. For example, if snapshot branch is named
   '1.1.0-SNAPSHOT', the version tag will be '1.1.0'.
*/
task releaseSnapshot {
	doLast {
		def branchName = grgit.branch.current().name
		checkClean()
		if ( !(branchName ==~ REGEX_SNAPSHOT()) ) {
			throw new GradleException('ERROR: Branch name does not match pattern '+REGEX_SNAPSHOT())
		}
		def tagName = branchName - '-SNAPSHOT'
		println 'Check out master branch'
		grgit.checkout(branch: 'master')
		println 'Merge changes from '+branchName
		grgit.merge(head: branchName, message: 'Merge changes from '+branchName)
		println 'Tag as '+tagName
		grgit.tag.add(name: tagName)
	}
}

/**
 Task to undo the changes made by the releaseSnapshot task. 
 
 Task prerequisites:
 - The releaseSnapshot task was run before
 - The current commit points to a tag created by the releaseSnapshot task
   (i.e. there have been no local or committed changes since the 
   releaseSnapshot task was run)
 
 Task actions:
 - Delete the tag created by the releaseSnapshot task
 - Check out the snapshot branch corresponding to the tagged version
*/
task undoReleaseSnapshot {
	doLast {
		checkClean()
		def tagName = getProjectVersion()
		if ( !(tagName ==~ REGEX_VERSION()) ) {
			throw new GradleException('ERROR: Not currently on a released version')
		}
		def branchName = tagName+'-SNAPSHOT'
		println 'Removing tag '+tagName
		grgit.tag.remove(names: [tagName])
		println 'Checking out '+branchName
		grgit.checkout(branch: branchName)
		println 'WARN: If this version was published to bintray, it must be manually removed'
	}
}

/*
 Task to start a new snapshot branch.
 
 Task prerequisites:
 - 'master' branch is currently checked out
 
 Task actions:
 - Create a new snapshot branch. If a 'nextVersion' property is defined,
   this task will check out the branch '<nextVersion>-SNAPSHOT', creating the
   branch if it does not yet exist. If no 'nextVersion' property is specified,
   the user will be asked for the next version number, providing a sensible
   default if possible.
*/
task startSnapshotBranch {
	// TODO Clean up / simplify this task
	doLast {
		def branchName = grgit.branch.current().name
		if ( branchName != 'master' ) {
			throw new GradleException('ERROR: Must be on master branch to start new snapshot branch')
		}
		def nextVersion = findProperty("nextVersion")
		if ( nextVersion == null ) {
			try {
				// GrGit doesn't support abbrev option, so we execute git directly
				def prevVersion = 'git describe --abbrev=0'.execute().text.trim()
				println 'Previous version: '+prevVersion
				if ( prevVersion!='' ) {
					def matcher = prevVersion =~ /^\d+\.(\d+)(\..+)*$/;
					def prevMinorVersion = matcher[0][1]
					def nextMinorVersion = (prevMinorVersion as int)+1
					nextVersion = prevVersion.replaceFirst(/^(\d+)\.\d+(\.\d+)*$/, '$1.'+nextMinorVersion+'$2')
				}
			} catch (Throwable e) {
				println 'INFO: Could not determine default next version due to '+e.getMessage() 
			}
			
			ant.input(message: 'Next version (default: '+nextVersion+'): ', addproperty: 'nextVersion', defaultValue: nextVersion)
			nextVersion = ant.nextVersion
		}
		if ( nextVersion==null || nextVersion=='' || nextVersion=='null' ) {
			throw new GradleException('ERROR: Next version must be provided')
		}
		if ( !(nextVersion ==~ REGEX_VERSION()) ) {
			throw new GradleException('ERROR: Next version must match '+REGEX_VERSION())
		}
		grgit.checkout(branch: nextVersion+'-SNAPSHOT', createBranch: true)
	}
	
	
}