def getProjectVersion() {
	def branchName = grgit.branch.current().name
	def gitDescribe = grgit.describe(tags: true, always: true)
	def isClean = grgit.status().isClean()
	if ( !isClean ) {
		gitDescribe += '-localchanges'
	}
	if ( !(gitDescribe ==~ /^(\d+.)+\d+$/) && branchName ==~ /^(\d+.)+\d+-SNAPSHOT$/ ) {
		return branchName
	} else {
		return gitDescribe
	}
}

def checkClean() {
	def isClean = grgit.status().isClean()
	if ( !isClean ) {
		throw new GradleException('ERROR: Working copy has uncommitted changes')
	}
}

ext {
    getProjectVersion = this.&getProjectVersion
    checkClean = this.&checkClean
}

task printProjectVersion {
    // any code that goes here is part of configuring the task
    // this code will always get run, even if the task is not executed
    doLast { // add a task action
        // any code that goes here is part of executing the task
        // this code will only get run if and when the task gets executed
        println project.version
    }
}

task releaseSnapshot {
	doLast {
		def branchName = grgit.branch.current().name
		checkClean()
		if ( !(branchName ==~ /^(\d+.)+\d+-SNAPSHOT$/) ) {
			throw new GradleException('ERROR: Branch name does not match pattern /^(\\d+.)+\\d+-SNAPSHOT$/')
		}
		def tagName = branchName - '-SNAPSHOT'
		println 'Check out master branch'
		grgit.checkout(branch: 'master')
		println 'Merge changes from '+branchName
		grgit.merge(head: branchName, message: 'Merge changes from '+branchName)
		println 'Tag as '+tagName
		grgit.tag.add(name: tagName)
	}
}

task undoReleaseSnapshot {
	doLast {
		checkClean()
		def tagName = getProjectVersion()
		if ( !(tagName ==~ /^(\d+.)+\d+$/) ) {
			throw new GradleException('ERROR: Not currently on a released version')
		}
		def branchName = tagName+'-SNAPSHOT'
		println 'Removing tag '+tagName
		grgit.tag.remove(names: [tagName])
		println 'Checking out '+branchName
		grgit.checkout(branch: branchName)
		println 'WARN: If this version was published to bintray, it must be manually removed'
	}
}

task startSnapshotBranch {
	// TODO Clean up / simplify this task
	doLast {
		def branchName = grgit.branch.current().name
		if ( branchName != 'master' ) {
			throw new GradleException('ERROR: Must be on master branch to start new snapshot branch')
		}
		def nextVersion = findProperty("nextVersion")
		if ( nextVersion == null ) {
			try {
				// GrGit doesn't support abbrev option, so we execute git directly
				def prevVersion = 'git describe --abbrev=0'.execute().text.trim()
				println 'Previous version: '+prevVersion
				if ( prevVersion!='' ) {
					def matcher = prevVersion =~ /^\d+\.(\d+)(\..+)*$/;
					def prevMinorVersion = matcher[0][1]
					def nextMinorVersion = (prevMinorVersion as int)+1
					nextVersion = prevVersion.replaceFirst(/^(\d+)\.\d+(\.\d+)*$/, '$1.'+nextMinorVersion+'$2')
				}
			} catch (Throwable e) {
				println 'INFO: Could not determine default next version due to '+e.getMessage() 
			}
			
			ant.input(message: 'Next version (default: '+nextVersion+'): ', addproperty: 'nextVersion', defaultValue: nextVersion)
			nextVersion = ant.nextVersion
		}
		if ( nextVersion==null || nextVersion=='' || nextVersion=='null' ) {
			throw new GradleException('ERROR: Next version must be provided')
		}
		if ( !(nextVersion ==~ /^(\d+.)+\d+$/) ) {
			throw new GradleException('ERROR: Next version must match /^(\\d+.)+\\d+$/')
		}
		grgit.checkout(branch: nextVersion+'-SNAPSHOT', createBranch: true)
	}
	
	
}